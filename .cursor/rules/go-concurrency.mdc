---
description: 
globs: 
alwaysApply: false
---
# GO_CONCURRENCY_RULES ⚡ **GO_ONLY**

PURPOSE: **ПРАВИЛА ТОЛЬКО ДЛЯ GO КОДА** - безопасная параллельность с использованием goroutines, mutex и errgroup.

1. SHARED_DATA_PROTECTION_POLICY
    GLOBAL_SCOPE_ACCESS: SYNC_RWMUTEX_MANDATORY
    MULTI_GOROUTINE_ACCESS: SYNC_RWMUTEX_MANDATORY
    WRITE_ONLY_OPERATIONS: SYNC_MUTEX_ALLOWED
    NUMERIC_OPERATIONS: ATOMIC_PACKAGE_MANDATORY
    MUTEX_PLACEMENT: NEAR_SHARED_DATA_DECLARATION
    EXAMPLES:
        READ_WRITE_SHARED:
            var (
                cache map[string]interface{}
                mx    sync.RWMutex
            )
            func init() { cache = make(map[string]interface{}) }
        WRITE_ONLY_SHARED:
            var (
                counters map[string]int
                mx       sync.Mutex
            )
            func init() { counters = make(map[string]int) }
        ATOMIC_NUMBERS:
            var requestCount int64 // use atomic.AddInt64, atomic.LoadInt64

2. PARALLEL_EXECUTION_POLICY
    DEFAULT_PATTERN: GO_PLUS_SYNC_WAITGROUP
    WORKFLOW:
        BEFORE_GO: wg.Add(1)
        INSIDE_GOROUTINE: defer wg.Done()
        AFTER_ALL_GO: wg.Wait()
    ERROR_HANDLING_METHODS: ERRGROUP_WITHCONTEXT_MANDATORY
    ERRGROUP_WORKFLOW:
        INITIALIZATION: eg, egCtx := errgroup.WithContext(ctx)
        GOROUTINE_CREATION: eg.Go(func() error { ... })
        CONTEXT_USAGE: USE_egCtx_INSTEAD_OF_ctx_INSIDE_GOROUTINES
        WAITING: err := eg.Wait()

3. ASYNC_DATA_COLLECTION_POLICY
    DATA_RETRIEVAL: CLOSURE_VARIABLES_MANDATORY
    PATTERN:
        DECLARE_VARS_BEFORE_GO: var result SomeType
        FILL_INSIDE_GOROUTINE: result = computedValue
        PROTECT_WITH_MUTEX_IF_NEEDED: mx.Lock(); data = value; mx.Unlock()
    SLICE_OPTIMIZATION: USE_PREDEFINED_SIZE_SLICE_WITH_INDEX_ACCESS
    EXAMPLE_SLICE_PATTERN:
        results := make([]Result, len(inputs))
        
        eg, egCtx := errgroup.WithContext(ctx)
        for i, input := range inputs {
            i, input := i, input // capture loop vars (only Go < 1.24)
            eg.Go(func() error {
                result, err := processInput(egCtx, input)
                if err != nil {
                    return errfmt.Error(err, "process input failed", "index", i)
                }
                results[i] = result
                
                return nil
            })
        }
        
        return results, eg.Wait()

4. CHANNEL_USAGE_RESTRICTION_POLICY
    DEFAULT_APPROACH: AVOID_CHANNELS_PREFER_WAITGROUP_ERRGROUP
    CHANNEL_ALLOWED_CASES: SINGLE_ASYNC_OPERATION_WITH_CONTEXT_CANCELLATION_ONLY
    APPROVAL_REQUIRED: REQUEST_PERMISSION_FOR_CHANNEL_USAGE
    ALTERNATIVE_REQUIRED: PROVIDE_NON_CHANNEL_IMPLEMENTATION_FIRST
    ALLOWED_PATTERN:
        finish := make(chan struct{})
        go func() {
            defer close(finish)
            // async operation
        }()
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-finish:
            return nil
        }

5. EXAMPLES_PATTERNS
    BASIC_PARALLEL_PROCESSING:
        '''
        var wg sync.WaitGroup
        
        for _, item := range items {
            wg.Add(1)
            go func(item Item) {
                defer wg.Done()
                processItem(item)
            }(item)
        }
        
        wg.Wait()
        '''
    PARALLEL_WITH_ERROR_HANDLING:
        '''
        eg, egCtx := errgroup.WithContext(ctx)
        
        for _, item := range items {
            item := item // only Go < 1.24
            eg.Go(func() error {
                err := processItem(egCtx, item)
                if err != nil {
                    return errfmt.Error(err, "process item failed")
                }
                
                return nil
            })
        }
        
        return eg.Wait()
        '''
    DATA_COLLECTION_WITH_SLICE:
        '''
        results := make([]Result, len(inputs))
        
        eg, egCtx := errgroup.WithContext(ctx)
        for i, input := range inputs {
            i, input := i, input // only Go < 1.24
            eg.Go(func() error {
                result, err := processInput(egCtx, input)
                if err != nil {
                    return errfmt.Error(err, "process input failed", "index", i)
                }
                results[i] = result
                
                return nil
            })
        }
        
        return results, eg.Wait()
        '''
